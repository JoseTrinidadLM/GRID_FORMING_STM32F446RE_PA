/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/*
 *  PA0 -> ADC1 -> DMA -> raw_sensor_value[0] -> characterized sensor outputs
 *			^
 *			|
 * 			TIM2
 *
 *	ClosedLoop/OpenLoop Operation Mode -> dutyCycle -> PWM
 *
 *
 */

/*
 * USART 2->STLINK
 *
 * TX->PA2
 * RX->PA3
 *
 */

#include <string.h>
#include "stm32f446xx.h"

uint64_t BUFFER_SIZE = 9;

/*characterized sensor outputs*/
float v_cd;
float v_g;
float i_L;
float i_L90;
float i_inv;

float ElapsedTime=0;	//Elapsed time variable

char packets_keys[] = {'V','C','F','D','Z','S','X','N'};
float packets_value[5]; 	//Data packet to be sent via UART
int valid_send = 1;		//Flag to indicate when data packet is ready to be sent

uint8_t status = 0b00000000; //Status variable to monitor system states
uint8_t frequency = 96;

uint8_t receive_data[3];

/*sine wave for DQ and power-factor correction*/
float cosine;
float sine;

float i_Q;


/*modulator signal*/
__vo uint16_t u_control_pos;
__vo uint16_t u_control_neg;


uint8_t OPERATION_MODE = 0;

GPIO_Handle_t PWM_EN;
GPIO_Handle_t LOOP_SEL;

/*GPIO pins 14-15 from port B are declared as input that activate EXTI15_10 to control PWM on/off, as well as change Operation Mode*/
void Utility_GPIOInits(void)
{
	GPIO_PClkC(GPIOB, ENABLE);
	PWM_EN.pGPIOx = GPIOB;
	PWM_EN.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_14;
	PWM_EN.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IT_RFT;
	PWM_EN.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
	GPIO_Init(&PWM_EN);

	LOOP_SEL.pGPIOx = GPIOB;
	LOOP_SEL.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_15;
	LOOP_SEL.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IT_RFT;
	LOOP_SEL.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
	GPIO_Init(&LOOP_SEL);

	GPIO_IRQInterruptConfig(IRQ_NO_EXTI15_10,ENABLE);
	GPIO_IRQPriorityConfig(IRQ_NO_EXTI15_10, 0);
}

GPIO_Handle_t GpioPWMA;
GPIO_Handle_t GpioPWMB;

/*GPIO pin 7 from port C and GPIO pin 6 from port B are declared as High Output Speed for PWM signals*/
void PWM_GPIOInits(void)
{
	GPIO_PClkC(GPIOB, ENABLE);

	GpioPWMA.pGPIOx = GPIOB;
	GpioPWMA.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_7;
	GpioPWMA.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	GpioPWMA.GPIO_PinConfig.GPIO_PinAltFunMode = 2;
	GpioPWMA.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;
	GpioPWMA.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	GpioPWMA.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	GPIO_Init(&GpioPWMA);

	GpioPWMB.pGPIOx = GPIOB;
	GpioPWMB.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_6;
	GpioPWMB.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	GpioPWMB.GPIO_PinConfig.GPIO_PinAltFunMode = 2;
	GpioPWMB.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;
	GpioPWMB.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	GpioPWMB.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	GPIO_Init(&GpioPWMB);
}

GPIO_Handle_t GPIO_Sensor[4];
ADC_Handle_t ADC_1;
DMA_Handle_t DMA2_ADC1Handle;
uint32_t raw_sensor_value[4];												//ADC1 destination buffer
float	sensor[9][4];														//processed data buffer (?)

/*Add as much sensors you want to read (look up pinout for compatibility) */

void Sensors_Init(void) /*For this application only 4 sensors will be initialized (name may be changed)*/
{
	/*****************GPIO analog inputs initialization*****************/
	GPIO_PClkC(GPIOA, ENABLE);

	GPIO_Sensor[0].pGPIOx = GPIOA;
	GPIO_Sensor[0].GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ANALOG;
	GPIO_Sensor[0].GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_0;
	GPIO_Sensor[0].GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
	GPIO_Init(&GPIO_Sensor[0]);

	GPIO_Sensor[1].pGPIOx = GPIOA;
	GPIO_Sensor[1].GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ANALOG;
	GPIO_Sensor[1].GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_1;
	GPIO_Sensor[1].GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
	GPIO_Init(&GPIO_Sensor[1]);

	GPIO_Sensor[2].pGPIOx = GPIOA;
	GPIO_Sensor[2].GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ANALOG;
	GPIO_Sensor[2].GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_4;
	GPIO_Sensor[2].GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
	GPIO_Init(&GPIO_Sensor[2]);


	GPIO_Sensor[3].pGPIOx = GPIOA;
	GPIO_Sensor[3].GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ANALOG;
	GPIO_Sensor[3].GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_6;
	GPIO_Sensor[3].GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
	GPIO_Init(&GPIO_Sensor[3]);

	/*****************ADC1 initialization*****************/

	/*ADC configured to start conversion by external trigger set by TIM2 and transfer data via DMA*/
	ADC_PClkC(ADC1, ENABLE);

   	ADC_1.pADCx = ADC1;
	ADC_1.ADC_Config.ADC_Resolution = ADC_RESOLUTION_12_B; 							//Max resolution
	ADC_1.ADC_Config.ADC_DataAlignment = ADC_DATA_ALIGNMENT_RIGHT; 					//Aligned to right to keep format of MSB-LSB
	ADC_1.ADC_Config.ADC_ScanMode =  ADC_SCAN_MODE_EN; 								//Since we want to read several pins, scan mode is enabled
	ADC_1.ADC_Config.ADC_ConversionMode =  ADC_CONV_MODE_SINGLE; 					//It converts just once
	ADC_1.ADC_Config.ADC_ExternalTriggerDetection =  ADC_EXT_TRIG_DECT_RE; 			//Starts conversion every rising edge of an external trigger
	ADC_1.ADC_Config.ADC_ExternalTrigger =  ADC_EXT_TRIG_TIM2_TRGO; 				//External trigger is commanded by TIM2
	ADC_1.ADC_Config.ADC_DMAContinuousRequests =  ADC_DMA_MODE_EN;					//Enables DMA
	ADC_1.ADC_Config.ADC_DDSelection =  ADC_DDS_RQ;									//DMA requests are issued as long as data are converted and DMA=1
	ADC_1.ADC_Config.ADC_EOCSelection =  ADC_EOC_PER_CONVERSION; 					//This set EOC flag to 1 at the end of each regular conversion
	ADC_1.ADC_Config.ADC_EOCInterrupt =  ADC_EOC_IT_DI; 							//Is disabled, ADC conversion and transfer of data is handled on TIM2_IRQHandler

	/*User may config reading sequence*/
	ADC_1.ADC_NumChannels = 4;
	ADC_ChannelConfig(&ADC_1, GPIO_PIN_NO_0, 0, ADC_SMP_T_15);						//Starts sequence on GPIO A0
	ADC_ChannelConfig(&ADC_1, GPIO_PIN_NO_1, 1, ADC_SMP_T_15);
	ADC_ChannelConfig(&ADC_1, GPIO_PIN_NO_4, 2, ADC_SMP_T_15);
	ADC_ChannelConfig(&ADC_1, GPIO_PIN_NO_6, 3, ADC_SMP_T_15);						//Ends sequence on GPIO A6
	ADC_ConfigSequence(&ADC_1);
	ADC_Init(&ADC_1);

	/*****************DMA initialization*****************/
	DMA_PClkC(DMA2, ENABLE);

	/*To transfer data from ADC1 to memory it uses Channel 0 and Stream 0*/
	/*To change this look up to Table 28-29 of RM0390 p.205*/
	DMA2_ADC1Handle.pDMAx = DMA2;

	DMA2_ADC1Handle.DMA_stream = 0;
	DMA2_ADC1Handle.DMA_Config.DMA_Channel = DMA_CHANNEL_0;
	DMA2_ADC1Handle.DMA_Config.DMA_Direction = DMA_DIR_PERIPH_TO_MEM;							//Transfers from ADC1 to local buffer
	DMA2_ADC1Handle.DMA_Config.DMA_Priority = DMA_PRIORITY_HIGH;
	DMA2_ADC1Handle.DMA_Config.DMA_MemDataSize = DMA_DATA_SIZE_WORD;							//Resolution is set to 12 bits, so Halfword can work, but since later it'll be be processed to a float it was set to the same size
	DMA2_ADC1Handle.DMA_Config.DMA_PeriphDataSize = DMA_DATA_SIZE_WORD;
	DMA2_ADC1Handle.DMA_Config.DMA_MemInc = ENABLE;											//Memory address pointer incremented after each data transfer (increment is done according to DMA_MemDataSize)
	DMA2_ADC1Handle.DMA_Config.DMA_PeriphInc = DISABLE;										//It's disabled, since we're reading just one peripheral
	DMA2_ADC1Handle.DMA_Config.DMA_FIFOMode = DMA_FIFO_MODE_DISABLED;
	DMA2_ADC1Handle.DMA_Config.DMA_FIFOThreshold = 0;
	DMA2_ADC1Handle.DMA_Config.DMA_Mode = DMA_MODE_CIRCULAR;									//We want to transfer continuously through the same peripheral to the same buffer
	DMA2_ADC1Handle.BufferSize = 4; 															//Same number of sensors added

	DMA_Init(&DMA2_ADC1Handle);
	DMA_SetAddresses(&DMA2_ADC1Handle,(void*)&ADC_1.pADCx->DR,(void*)raw_sensor_value);
	DMA_StartTransfer(&DMA2_ADC1Handle);
}

TIM_Handle_t TIM_2;

void SamplingRateTIMInit(float sampling_rate)
{

	TIM_2.pTIMx = TIM2;
	TIM_2.TIM_Config.TIM_Frequency = sampling_rate;
	TIM_2.TIM_Config.TIM_CLKDivision = TIM_CKD_DIV1;
	TIM_2.TIM_Config.TIM_AutoReloadPreload = TIM_ARPE_ENABLE;
	TIM_2.TIM_Config.TIM_CNTMode = TIM_UPCOUNT_MODE;
	TIM_2.TIM_Config.TIM_IntEnable = TIM_IT_ENABLE;
	TIM_2.TIM_Config.TIM_MasterModeSel = TIM_MMS_UPDATE; 							//Master Mode established as update to trigger ADC1 conversion
	TIM_Init(&TIM_2);

	TIM_IRQInterruptConfig(IRQ_NO_TIM2, ENABLE);
	TIM_IRQPriorityConfig(IRQ_NO_TIM2, 1);
}

TIM_Handle_t TIM_4;
PWM_Config_t TIM4_PWM_Channel_1;
PWM_Config_t TIM4_PWM_Channel_2;

/*To create PWM signals with 180-phase shift it is needed to sync dirrefent timer by srtting a master-slave */
void PWM_TIMInits(float carrier_frequency)
{

	/*****************Master Timer initialization*****************/
	TIM_PClkC(TIM4, ENABLE);

	TIM_4.pTIMx = TIM4;
	TIM_4.TIM_Config.TIM_Frequency = carrier_frequency;
	TIM_4.TIM_Config.TIM_CLKDivision = TIM_CKD_DIV1;
	TIM_4.TIM_Config.TIM_AutoReloadPreload = TIM_ARPE_ENABLE;
	TIM_4.TIM_Config.TIM_CAModeSel = TIM_CMS_EDGE;
	TIM_4.TIM_Config.TIM_IntEnable = TIM_IT_DISABLE;
	TIM_4.TIM_Config.TIM_MasterModeSel = TIM_MMS_RESET;

	TIM_Init(&TIM_4);

	TIM4_PWM_Channel_1.PWM_Channel = PWM_CHANNEL_1;
	TIM4_PWM_Channel_1.PWM_OCMode = TIM_PWM_MODE2;
	TIM4_PWM_Channel_1.PWM_OCPolarity = PWM_OC_POLARITY_HIGH;
	TIM4_PWM_Channel_1.PWM_OCPolarity  = PWM_OC_PRELOAD_DISABLED;

	TIM_PWM_Channel_Init(&TIM_4, &TIM4_PWM_Channel_1);

	TIM4_PWM_Channel_2.PWM_Channel = PWM_CHANNEL_2;
	TIM4_PWM_Channel_2.PWM_OCMode = TIM_PWM_MODE2;
	TIM4_PWM_Channel_2.PWM_OCPolarity = PWM_OC_POLARITY_HIGH;
	TIM4_PWM_Channel_2.PWM_OCPolarity  = PWM_OC_PRELOAD_DISABLED;

	TIM_PWM_Channel_Init(&TIM_4, &TIM4_PWM_Channel_2);

	TIM_Start(&TIM_4);  //Starting timer just for minimal tests

}

/*ALL PARAMETERS AND DESIGN OF THIS FUNCTION ARE GIVEN FOR A 60 HZ SIGNAL***/
float NINETYDegreePhaseShift(float *pCos_Buffer, float cos_wave, __vo uint8_t *pBuffer_Counter, __vo uint8_t *pBuffer_Ready_Flag)
{
	float temp_sin = 0;

	//temp_sin stores a 90-degree phase shift signal
	//This buffer stores a quarter a of period of a 60 Hz sine wave
	if(*pBuffer_Ready_Flag == 1) temp_sin =  pCos_Buffer[*pBuffer_Counter];

	//Updates current buffer after saving the temp_sine wave

	pCos_Buffer[*pBuffer_Counter] = cos_wave;

	//Counter updates
	(*pBuffer_Counter)++;

	//Once the buffer is completely filled counter is reset
	if(*pBuffer_Counter >= 40)									//This condition is subject to sampling rate being 9.6 kHz and grid-load fundamental frequency are 60 Hz
	{															//Buffer may be larger but to store and create a ring-buffer we only take account of the first quarter of a period
		*pBuffer_Ready_Flag = 1;
		*pBuffer_Counter = 0;
	}
	return temp_sin;
}

/*This function computes partially the Park Transformation of two-phase orthogonal components its output returns the quadrature axis component */
float DTransform(float cosine_wt, float sine_wt, float alpha, float beta)
{
	return (alpha*cosine_wt + beta*sine_wt);
}

/*This function computes partially the Park Transformation of two-phase orthogonal components its output returns the direct axis component */
float QTransform(float cosine_wt, float sine_wt, float alpha, float beta)
{
	return (-alpha*sine_wt + beta*cosine_wt);
}

/*Parametres highly tied to sampling rate being 9600*/
/*To differentiate local varaibles from global variables names in local instance for this function have been written in caps*/
void CascadeControl(float cosine_wt, float sine_wt, float V_CD, float I_Q, float I_INV, __vo float *pe1_z_0, __vo float *pe1_z_1, __vo float *pe2_z_0, __vo float *pe2_z_1, __vo float *py1_z_0, __vo float *py1_z_1, __vo float *py2_z_0, __vo float *py2_z_1, __vo uint16_t *u_pos, __vo uint16_t *u_neg)
{
	float u_pos_temp = 0;
	float u_neg_temp = 0;

	(*pe1_z_0) = 36 - V_CD;														//Evaluates error among reference and DC sensed value on DC bus of the inverter

	(*py1_z_0) = (*py1_z_1) + 0.167037*(*pe1_z_0) - 0.167028*(*pe1_z_1);		//External discrete PI control loop

	(*pe1_z_1) = (*pe1_z_0);													//Updating last error as the most recent one
	(*py1_z_1) = (*py1_z_0);													//Updating last output PI control value as the most recent one

	(*pe2_z_0) = (*py1_z_0)*cosine_wt + (7.8 + I_Q)*sine_wt - I_INV; 			//Calculates the new error with a reference given by external control loop output, quadrature current and inverter sense current

	(*py2_z_0) = (*py2_z_1) - 0.03203*(*pe2_z_0) + 0.03087*(*pe2_z_1); 			//Internal discrete PI control loop

	if((*py2_z_0)> (0.99)) (*py2_z_0) = 0.99;
	if((*py2_z_0)< (-0.99)) (*py2_z_0) = -0.99;									//Setting boundaries for control signal

	(*pe2_z_1) = (*pe2_z_0);													//Updating last error as the most recent one
	(*py2_z_1) = (*py2_z_0);													//Updating last output PI control value as the most recent one

	u_pos_temp = (((*py2_z_0 )*(0.5)) + 0.5)*(TIM4->ARR);
	u_neg_temp = (((*py2_z_0 )*(-0.5)) + 0.5)*(TIM4->ARR);

	(*u_pos) = (uint16_t)u_pos_temp;				 							//Updates positive control signal in relation to PWM resolution
	(*u_neg) = (uint16_t)u_neg_temp;											//Updates negative control signal in relation to PWM resolution

}

void OpenLoop(float cosine_wt, __vo uint16_t *u_pos, __vo uint16_t *u_neg)
{
	float u_pos_temp = 0;
	float u_neg_temp = 0;

	u_pos_temp = ((cosine_wt*0.5) + 0.5)*(TIM4->ARR);
	u_neg_temp = ((-cosine_wt*0.5) + 0.5)*(TIM4->ARR);

	(*u_pos) = (uint16_t)u_pos_temp;				 							//Updates positive control signal in relation to PWM resolution
	(*u_neg) = (uint16_t)u_neg_temp;											//Updates negative control signal in relation to PWM resolution
}

/*This functions resets CascadeControl() input-output parameters*/
void ResetPIControllers(__vo float *pe1_z_0, __vo float *pe1_z_1, __vo float *pe2_z_0, __vo float *pe2_z_1, __vo float *py1_z_0, __vo float *py1_z_1, __vo float *py2_z_0, __vo float *py2_z_1)
{
	(*pe1_z_0) = 0;
	(*pe1_z_1) = 0;

	(*py1_z_0) = 0;
	(*py1_z_1) = 0;

	(*pe2_z_0) = 0;
	(*pe2_z_1) = 0;

	(*py2_z_0) = 0;
	(*py2_z_1) = 0;
}

uint8_t heartbeat[5];
uint8_t telemetry[35];

uint8_t dma_ready;
uint8_t telemetry_status;
uint8_t heartbeat_status;

#define DMA_TR_NONE			0
#define DMA_TR_TELEMETRY	1
#define DMA_TR_HEARTBEAT	2

uint8_t dma_transfer_mode = DMA_TR_NONE;

/*This function set the values for USART buffer*/
void USART_SetBuffer()
{
	if (valid_send == 1) {
		packets_value[0] = v_g;
		packets_value[1] = i_L ;
		packets_value[2] = i_inv;
		packets_value[3] = v_cd;
		packets_value[4] = ElapsedTime;
		valid_send = 0;
		telemetry_status = ENABLE;
	}else {
		valid_send = 1;
	}
}

/*This function resets the value of Elapsed time*/
void ResetTime(void)
{
	ElapsedTime = 0;
}

void executeCommand(uint8_t command)
{
	status = command;
}

uint8_t getValue_Variable(char s, uint8_t byteIndex)
{
	uint8_t x;
	for(x = 0; packets_keys[x] != s; x++);

	uint32_t *p = (uint32_t*)&packets_value[x];

	return (*p >> ((3-byteIndex)*8)) & 0xFF;
}
/*
void addValue_Variable(char s, uint8_t message[7])
{
	int x;
	for(x = 0; packets_keys[x] != s; x++);
	for(int y = 2; y < 6; y++)
	{
		packets_value[x] |= (message[x] << (y-2)*8) & 0xFF;
	}
}
*/
void heartbeatStructure(void)
{
	heartbeat[0] = '$';
	heartbeat[1] = 'S';
	heartbeat[2] = 2;
}

void telemetryStructure(void)
{
	telemetry[0] = '$';
	telemetry[1] = 'V';
	telemetry[2] = 4;
	telemetry[7] = '$';
	telemetry[8] = 'C';
	telemetry[9] = 4;
	telemetry[14] = '$';
	telemetry[15] = 'F';
	telemetry[16] = 4;
	telemetry[21] = '$';
	telemetry[22] = 'D';
	telemetry[23] = 4;
	telemetry[28] = '$';
	telemetry[29] = 'Z';
	telemetry[30] = 4;
}

USART_Handle_t USART2Handle;

TIM_Handle_t TIM3Handle ;

GPIO_Handle_t LED;

DMA_Handle_t DMA1_TX2Handle;

DMA_Handle_t DMA1_RX2Handle;

void LED_GPIOInits(void)
{
	LED.pGPIOx = GPIOA;
	LED.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	//LED.GPIO_PinConfig.GPIO_PinAltFunMode = 2;
	LED.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	LED.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
	LED.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
	//LED D13
	LED.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_5;
	GPIO_Init(&LED);
}

void TIM3_Inits(TIM_Handle_t *pTIM3Handle)
{
	pTIM3Handle->pTIMx = TIM3;
	pTIM3Handle->TIM_Config.TIM_AutoReloadPreload = TIM_ARPE_ENABLE;
	pTIM3Handle->TIM_Config.TIM_CLKDivision = TIM_CKD_DIV1;
	pTIM3Handle->TIM_Config.TIM_CNTMode = TIM_UPCOUNT_MODE;
	pTIM3Handle->TIM_Config.TIM_Frequency = 1;
	pTIM3Handle->TIM_Config.TIM_IntEnable = TIM_IT_ENABLE;
	pTIM3Handle->TIM_Config.TIM_MasterModeSel = TIM_MMS_UPDATE;

	TIM_Init(pTIM3Handle);
}

void USART2_GPIOInits(void)
{
	GPIO_Handle_t USART2pin;
	USART2pin.pGPIOx = GPIOA;
	USART2pin.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	USART2pin.GPIO_PinConfig.GPIO_PinAltFunMode = 7;
	USART2pin.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	USART2pin.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
	USART2pin.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
	//TX
	USART2pin.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_2;
	GPIO_Init(&USART2pin);
	//RX
	USART2pin.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_3;
	GPIO_Init(&USART2pin);
}

void USART2_Inits(USART_Handle_t *pUSART2Handle)
{
	pUSART2Handle->pUSARTx = USART2;
	pUSART2Handle->USARTConfig.USART_Baud = 2200000;
	pUSART2Handle->USARTConfig.USART_HWFlowControl = USART_HW_FC_NONE;
	pUSART2Handle->USARTConfig.USART_Mode = USART_MODE_TX_RX;
	pUSART2Handle->USARTConfig.USART_NoOfStopBits = USART_1_STOPBITS;
	pUSART2Handle->USARTConfig.USART_ParityControl = USART_PARITY_DISABLE;
	pUSART2Handle->USARTConfig.USART_WordLength = USART_WLEN_8BITS;
	pUSART2Handle->USARTConfig.USART_DMA = USART_DMA_TX_RX;

	USART_Init(pUSART2Handle);
}

void DMA1_Inits(void)
{
	//DMA1 Channel 4 Stream 6 USART2 TX
	DMA1_TX2Handle.pDMAx = DMA1;
	DMA1_TX2Handle.DMA_stream = 6;
	DMA1_TX2Handle.DMA_Config.DMA_Channel = DMA_CHANNEL_4;
	DMA1_TX2Handle.DMA_Config.DMA_Direction = DMA_DIR_MEM_TO_PERIPH;
	DMA1_TX2Handle.DMA_Config.DMA_Priority = DMA_PRIORITY_MEDIUM;
	DMA1_TX2Handle.DMA_Config.DMA_MemDataSize = DMA_DATA_SIZE_BYTE;
	DMA1_TX2Handle.DMA_Config.DMA_PeriphDataSize = DMA_DATA_SIZE_BYTE;
	DMA1_TX2Handle.DMA_Config.DMA_MemInc = ENABLE;
	DMA1_TX2Handle.DMA_Config.DMA_PeriphInc = DISABLE;
	DMA1_TX2Handle.DMA_Config.DMA_FIFOMode = DMA_FIFO_MODE_DISABLED;
	DMA1_TX2Handle.DMA_Config.DMA_FIFOThreshold = 0;
	DMA1_TX2Handle.DMA_Config.DMA_Mode = DMA_MODE_NORMAL;
	DMA1_TX2Handle.DMA_Config.DMA_TransferIT = ENABLE;
	DMA1_TX2Handle.BufferSize = 4;

	DMA_Init(&DMA1_TX2Handle);

	//DMA1 Channel 4 Stream 5 USART2 RX
	DMA1_RX2Handle.pDMAx = DMA1;
	DMA1_RX2Handle.DMA_stream = 5;
	DMA1_RX2Handle.DMA_Config.DMA_Channel = DMA_CHANNEL_4;
	DMA1_RX2Handle.DMA_Config.DMA_Direction = DMA_DIR_PERIPH_TO_MEM;
	DMA1_RX2Handle.DMA_Config.DMA_MemDataSize = DMA_DATA_SIZE_BYTE;
	DMA1_RX2Handle.DMA_Config.DMA_PeriphDataSize = DMA_DATA_SIZE_BYTE;
	DMA1_RX2Handle.DMA_Config.DMA_MemInc = ENABLE;
	DMA1_RX2Handle.DMA_Config.DMA_PeriphInc = DISABLE;
	DMA1_RX2Handle.DMA_Config.DMA_FIFOMode = DMA_FIFO_MODE_DISABLED;
	DMA1_RX2Handle.DMA_Config.DMA_FIFOThreshold = 0;
	DMA1_RX2Handle.DMA_Config.DMA_Mode = DMA_MODE_CIRCULAR;
	DMA1_RX2Handle.DMA_Config.DMA_TransferIT = ENABLE;
	DMA1_RX2Handle.BufferSize = 3;

	DMA_Init(&DMA1_RX2Handle);
	DMA_SetAddresses(&DMA1_RX2Handle, (void*)&USART2Handle.pUSARTx->DR, (void*)receive_data);
	DMA_StartTransfer(&DMA1_RX2Handle);
}

void USART_HeartBeatTX(void);
void USART_TelemetryTX(void);

int main(void)
{
	SystemCLK_Config_84MHz();

	SCB_CPACR |= ((3UL << 10*2) | (3UL << 11*2)); //FPU Enabled

	Utility_GPIOInits();
	PWM_GPIOInits();
	Sensors_Init();
	SamplingRateTIMInit(9600);
	PWM_TIMInits(9600);

    USART2_GPIOInits();
	USART2_Inits(&USART2Handle);
	USART_PeripheralControl(USART2Handle.pUSARTx, ENABLE);

	//TIM3_GPIOInits();
	TIM3_Inits(&TIM3Handle);

	TIM_IRQInterruptConfig(IRQ_NO_TIM3,ENABLE);
	TIM_IRQPriorityConfig(IRQ_NO_TIM3,NVIC_IRQ_PRI15);

	LED_GPIOInits();

	//DMA 1 Channel 4 Stream 5 & 6
	DMA1_Inits();
	DMA_IRQInterruptConfig(IRQ_NO_DMA1_STREAM6,ENABLE);
	DMA_IRQPriorityConfig(IRQ_NO_DMA1_STREAM6,NVIC_IRQ_PRI1);
	DMA_IRQInterruptConfig(IRQ_NO_DMA1_STREAM5,ENABLE);
	DMA_IRQPriorityConfig(IRQ_NO_DMA1_STREAM5,NVIC_IRQ_PRI1);

	heartbeatStructure();
	telemetryStructure();

	TIM_Start(&TIM_2);
	TIM_Start(&TIM3Handle);

	dma_ready = ENABLE;

	while(1)
	{
		USART_TelemetryTX();
		USART_HeartBeatTX();
	}
	return 0;
}


/*Buffers to store quarter of a period of cos and i_L*/
/*For every shifted signal it is needed a buffer*/
float cos_buffer[40] = {0};
float i_L_buffer[40] = {0};


/*Control global variables*/
__vo float e1_z_0 = 0;
__vo float e1_z_1 = 0;

__vo float e2_z_0 = 0;
__vo float e2_z_1 = 0;

__vo float y1_z_0 = 0;
__vo float y1_z_1 = 0;

__vo float y2_z_0 = 0;
__vo float y2_z_1 = 0;

void TIM2_IRQHandler(void)
{
	/*Flags and counters used for 90-degree shiftimg*/
	__vo static uint8_t Buffer_Counter_Cos = 0;
	__vo static uint8_t Buffer_Ready_Flag_Cos = 0;

	__vo static uint8_t Buffer_Counter_iL = 0;
	__vo static uint8_t Buffer_Ready_Flag_iL = 0;


	TIM_IRQHandling(&TIM_2);

	/*This are critical operations needed before shifting to Closed Loop Mode */

	/*TO DO: Read and characterize sensors */

	v_g = 	(raw_sensor_value[0]/4095.0f - 0.5f)*2.0f;
	i_inv = (raw_sensor_value[1]/4095.0f - 0.5f)*2.0f;
	i_L = 	(raw_sensor_value[2]/4095.0f - 0.5f)*2.0f;
	v_cd = 	(raw_sensor_value[3]/4095.0f - 0.5f)*2.0f;
	ElapsedTime = ElapsedTime + (1.0f/9600.0f);
	
	/*This is to refresh the packet_values in buffer for DMA*/
	USART_SetBuffer();

	/*In case there is a high presence of noise, signals will be filtered*/

	cosine = v_g;		//This is just an example to show its functionality

	sine = NINETYDegreePhaseShift(cos_buffer, cosine, &Buffer_Counter_Cos, &Buffer_Ready_Flag_Cos);

	i_L90 = NINETYDegreePhaseShift(i_L_buffer, i_L, &Buffer_Counter_iL, &Buffer_Ready_Flag_iL);
	
	i_Q = QTransform(cosine, sine, i_L, i_L90);

	if(OPERATION_MODE == 0)
	{
		OpenLoop(v_g, &u_control_pos, &u_control_neg);

	} else
	{
		CascadeControl(cosine, sine, v_cd, i_Q, i_inv, &e1_z_0, &e1_z_1, &e2_z_0, &e2_z_1, &y1_z_0, &y1_z_1, &y2_z_0, &y2_z_1, &u_control_pos, &u_control_neg);
	}

	TIM_PWM_DutyCycle(&TIM_4, &TIM4_PWM_Channel_1, u_control_pos);
	TIM_PWM_DutyCycle(&TIM_4, &TIM4_PWM_Channel_2, u_control_neg);

}

/*This interruption can be triggered by GPIOB 14-15*/
void EXTI15_10_IRQHandler(void)
{
	static uint8_t PWM_ENABLE = 0;
	GPIO_IRQHandling(14);
	/*Both pins are read*/
	PWM_ENABLE = GPIO_ReadFromInputPin(GPIOB, 14);
	OPERATION_MODE = GPIO_ReadFromInputPin(GPIOB, 15);				//This lecture autmatically changes Operation Mode as: Open Loop when Operation Mode = 0, Closed Loop when 1


	/*When Operation Mode is zero it resets PI controllers from CascadeControl(), to assure safe and smooth transition to Closed Loop Mode Operation*/
	if( OPERATION_MODE == 0 )
	{
		ResetPIControllers(&e1_z_0, &e1_z_1, &e2_z_0, &e2_z_1, &y1_z_0, &y1_z_1, &y2_z_0, &y2_z_1);
		status &= ~(1 << 0); //Set Loop Status Flag to Open 
	} else
	{
		status |= (1 << 0); //Set Loop Status Flag to Closed
	}

	/*To disable PWM output, when PWM_ENABLE is 0 TIM5 (which controls PWM GPIO C7-A9) is stopped and both pins are reset. When PWM_ENABLE is 1 it starts TIM5 again*/
	if( PWM_ENABLE == 0 )
	{
		TIM_PWM_Disable(&TIM_4, &TIM4_PWM_Channel_1);
		TIM_PWM_Disable(&TIM_4, &TIM4_PWM_Channel_2);

		GPIO_WriteToOutputPin(GPIOB, GPIO_PIN_NO_7, RESET);
		GPIO_WriteToOutputPin(GPIOB, GPIO_PIN_NO_6, RESET);

		status &= ~(1 << 1); //Set PWM Status Flag to Disabled

	} else if( PWM_ENABLE == 1 )
	{
		TIM_PWM_Enable(&TIM_4, &TIM4_PWM_Channel_1);
		TIM_PWM_Enable(&TIM_4, &TIM4_PWM_Channel_2);

		status |= (1 << 1); //Set PWM Status Flag to Enabled

	}
}

void ShiftSensorsValue(void)
{
	for(uint64_t x = BUFFER_SIZE-1; x>0; x--)
	{
		//TO-DO: shift processed values
		;
	}
}


uint64_t comm[3] = {0}; //lo anadi para revisar que compilara

void USART_DecodeRX(USART_Handle_t *pUSARTHandle)
{
	comm[0] = receive_data[0];
	comm[1] = receive_data[1];
	comm[2] = receive_data[2];
	if(receive_data[0] == '$' && receive_data[1] == 'X')
	{
		executeCommand(receive_data[2]);
	}
}

void USART_HeartBeatTX(void)
{
	if(dma_ready == DISABLE) return;
	if(heartbeat_status == DISABLE) return;
	USART_ClearFlag(USART2Handle.pUSARTx, USART_TC_FLAG);
	heartbeat[3] = status;
	heartbeat[4] = frequency;

	dma_transfer_mode = DMA_TR_HEARTBEAT;

	DMA_SetAddresses(&DMA1_TX2Handle, (void*)heartbeat, (void*)&USART2Handle.pUSARTx->DR);
	DMA_ConfigureBuffer(&DMA1_TX2Handle, 5);
	DMA_StartTransfer(&DMA1_TX2Handle);
}

void USART_TelemetryTX(void)
{
	if(dma_ready == DISABLE) return;
	if(telemetry_status == DISABLE) return;
	USART_ClearFlag(USART2Handle.pUSARTx, USART_TC_FLAG);
	telemetry[3] = getValue_Variable('V', 0);
	telemetry[4] = getValue_Variable('V', 1);
	telemetry[5] = getValue_Variable('V', 2);
	telemetry[6] = getValue_Variable('V', 3);

	telemetry[10] = getValue_Variable('C', 0);
	telemetry[11] = getValue_Variable('C', 1);
	telemetry[12] = getValue_Variable('C', 2);
	telemetry[13] = getValue_Variable('C', 3);

	telemetry[17] = getValue_Variable('F', 0);
	telemetry[18] = getValue_Variable('F', 1);
	telemetry[19] = getValue_Variable('F', 2);
	telemetry[20] = getValue_Variable('F', 3);

	telemetry[24] = getValue_Variable('D', 0);
	telemetry[25] = getValue_Variable('D', 1);
	telemetry[26] = getValue_Variable('D', 2);
	telemetry[27] = getValue_Variable('D', 3);

	telemetry[31] = getValue_Variable('Z', 0);
	telemetry[32] = getValue_Variable('Z', 1);
	telemetry[33] = getValue_Variable('Z', 2);
	telemetry[34] = getValue_Variable('Z', 3);

	dma_transfer_mode = DMA_TR_TELEMETRY;

	DMA_SetAddresses(&DMA1_TX2Handle, (void*)telemetry, (void*)&USART2Handle.pUSARTx->DR);
	DMA_ConfigureBuffer(&DMA1_TX2Handle, 35);
	DMA_StartTransfer(&DMA1_TX2Handle);
}

void TIM3_IRQHandler(void)
{
	heartbeat_status = ENABLE;
	TIM_IRQHandling(&TIM3Handle);
}

void DMA_ApplicationEventCallback(DMA_Handle_t *pDMAHandle, uint8_t ApEv)
{
	if(ApEv == DMA_EVENT_TCIF_CMPLT)
	{
		if(pDMAHandle->DMA_stream == 6)
		{
			DMA_StopTransfer(&DMA1_TX2Handle);
			dma_ready = ENABLE;
			if(dma_transfer_mode == DMA_TR_HEARTBEAT)
			{
				heartbeat_status = DISABLE;
			}else if(dma_transfer_mode == DMA_TR_TELEMETRY )
			{
				telemetry_status = DISABLE;
			}
			dma_transfer_mode = DMA_TR_NONE;
		}
		if(pDMAHandle->DMA_stream == 5)
		{
			USART_DecodeRX(&USART2Handle);
		}
	}
}

void DMA1_Stream6_IRQHandler(void)
{
	DMA_IRQHandling(&DMA1_TX2Handle);
}

void DMA1_Stream5_IRQHandler(void)
{
	DMA_IRQHandling(&DMA1_RX2Handle);
}
