/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/*
 *  PA0 -> ADC1 -> DMA -> raw_sensor_value[0] -> characterized sensor outputs
 *			^
 *			|
 * 			TIM2
 *
 *	ClosedLoop/OpenLoop Operation Mode -> dutyCycle -> PWM
 *
 *
 */

/*
 * USART 2->STLINK
 *
 * TX->PA2
 * RX->PA3
 *
 */

#include <string.h>
#include "stm32f446xx.h"

float packets_value[5]; 	//Data packet to be sent via UART

uint8_t testvar = 0;
 
uint8_t heartbeat[2];

GPIO_Handle_t LED;

void LED_GPIOInits(void)
{
	LED.pGPIOx = GPIOA;
	LED.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	//LED.GPIO_PinConfig.GPIO_PinAltFunMode = 2;
	LED.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	LED.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
	LED.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
	//LED D13
	LED.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_5;
	GPIO_Init(&LED);
}

int main(void)
{
	SystemCLK_Config_84MHz();

	SCB_CPACR |= ((3UL << 10*2) | (3UL << 11*2)); //FPU Enabled`

	ControlInit();
	Control_Stop();

	ProtocolInit(USART2, GPIOA, GPIOA, GPIO_PIN_NO_2, GPIO_PIN_NO_3, packets_value, heartbeat);
	Protocol_TIMInit(TIM3);
	Protocol_Start();

	//Call Protocol_Telemetry_EN() to send values in @packets_value

	LED_GPIOInits();
	while(1)
	{
		Protocol_HeartBeat();
		Protocol_Telemetry();
	}
	return 0;
}

/*********************************************************************************************************************************************************************
 * @fn                     LED_Indicator
 *
 * @brief                  Updates the Led Status depending on the last updated system state on heartbeat.
 * 
 * @param                  None
 *
 * @return                 None
 * 
 * @note                   - Reads system state on heartbeat.
 *                         - Calls write of GPIO pin for LED.
 *
 * @Requirements           7.1.2 [010.C10] [020.C10] [030.C10] [040.C10]
 * 
 *********************************************************************************************************************************************************************/

void LED_Indicator(void)
{
	if(((heartbeat[0] >> SYSTEM_STATUS_FLAG) & 0b1) == FLAG_SET)
	{
		GPIO_WriteToOutputPin(LED.pGPIOx, GPIO_PIN_NO_5, ENABLE);
	}else if(((heartbeat[0] >> SYSTEM_STATUS_FLAG) & 0b1) == FLAG_RESET)
	{
		GPIO_WriteToOutputPin(LED.pGPIOx, GPIO_PIN_NO_5, DISABLE);
	}
}

/*********************************************************************************************************************************************************************
 * @fn                     TIM3_IRQHandler
 *
 * @brief                  Handles Interrupts of timer for Heartbeat
 * 
 * @param                  None
 *
 * @return                 None
 * 
 * @note                   - Enables HeartBeat.
 *                         - Toggle LED if in Closed Loop Mode.
 *
 * @Requirements           7.2.3 [010] 7.1.2 [030.C10]
 * 
 *********************************************************************************************************************************************************************/

void TIM3_IRQHandler(void)
{
	Protocol_HeartBeat_EN();
	Protocol_TIMx_IRQHandling();
	if(((heartbeat[0] >> SYSTEM_STATUS_FLAG) & 0b1) && ((heartbeat[0] >> MODE_FLAG) & 0b1)) GPIO_ToggleOutputPin(LED.pGPIOx, GPIO_PIN_NO_5);
}

void DMA1_Stream6_IRQHandler(void)
{
	Protocol_DMAx_TX_IRQHandling();
}

void DMA1_Stream5_IRQHandler(void)
{
	Protocol_DMAx_RX_IRQHandling();
}

/*********************************************************************************************************************************************************************
 * @fn                     TIM2_IRQHandler
 *
 * @brief                  Handles Interrupts of timer for Sampling Rate.
 * 
 * @param                  values – Pointer to a float array where processed sensor values will be stored (size ≥ 5).
 *
 * @return                 uint8_t – Returns `valid_send` flag indicating whether new data was stored (FLAG_SET or FLAG_RESET).
 * 
 * @note                   - Calls function to reads sensor values.
 *                         - Reads flag to set Telemetry to Enable.
 *                         - Call function to compute PWM duty cycles.
 *
 * @Requirements           7.2.2 [010.C10] [020.C10]
 * 
 *********************************************************************************************************************************************************************/

void TIM2_IRQHandler(void)
{
	TIM2_IRQHandling();

	if(Control_ReadSensors(packets_value) == FLAG_RESET) Protocol_Telemetry_EN();
	
	Control_DutyCycle();

}

/*********************************************************************************************************************************************************************
 * @fn                     executeCommand
 *
 * @brief                  Executes the different commands receive from the Serial Communication.
 * 
 * @param[in]              command
 *
 * @return                 None
 * 
 * @note                   - Reads changes to System State from command.
 *                         - Calls function Control_Mode from Control drivers to request the changes in the System State, then reads the real System State.
 *                         - Updates LED Status.
 *
 * @Requirements           7.3.2 [030.C10] [040.C10] [050.C10] [060.C10]
 * 
 *********************************************************************************************************************************************************************/

void executeCommand(uint8_t command)
{
	if(command == 1)					//System ON
	{
		SYSTEM_ON_FLAG(heartbeat[0]);
	}else if(command == 2)				//System OFF
	{
		SYSTEM_OFF_FLAG(heartbeat[0]);
	}else if(command == 3)				//Open Loop
	{
		SET_OPEN_LOOP_MODE(heartbeat[0]);
	}else if(command == 4)				//Closed Loop
	{
		SET_CLOSED_LOOP_MODE(heartbeat[0]);
	}
	heartbeat[0] = Control_Mode(heartbeat[0] & 0b1, (heartbeat[0] >> 1) & 0b1); //Introduce Power & Loop values
	LED_Indicator();
}

/*********************************************************************************************************************************************************************
 * @fn                     EXTI15_10_IRQHandler
 *
 * @brief                  Handles the Interrupts of pin 14 and 15 of port B. Toggles the power(pin 15) and operation mode(pin 14) of the system after a high on the pins.
 * 
 * @param                  None
 *
 * @return                 None
 * 
 * @note                   - Calls reading of GPIO inputs.
 *                         - Calls function Control_Mode from Control drivers to request the changes in the System State, then reads the real System State.
 *                         - Updates LED Status.
 *
 * @Requirements           7.1.2 [010.C10] [020.C10] [030.C10] [040.C10]
 * 
 *********************************************************************************************************************************************************************/
void EXTI15_10_IRQHandler(void)
{
	uint8_t temp_toggle_loop = GPIO_ReadFromInputPin(GPIOB, GPIO_PIN_NO_14);
	uint8_t temp_toggle_power = GPIO_ReadFromInputPin(GPIOB, GPIO_PIN_NO_15);

	GPIO_IRQHandling(GPIO_PIN_NO_14);
	GPIO_IRQHandling(GPIO_PIN_NO_15);

	if (temp_toggle_power){
		heartbeat[0] ^= (1 << 0); //toggle power bit if button pressed
	} 
	if (temp_toggle_loop){
		heartbeat[0] ^= (1 << 1); //toggle loop bit if button pressed
	} 

	heartbeat[0] = Control_Mode(heartbeat[0] & 0b1, (heartbeat[0] >> 1) & 0b1); //Introduce Power & Loop values (TO-DO: maybe change to main.c)
	LED_Indicator();
}


uint64_t comm[3] = {RESET}; //lo anadi para revisar que compilara

