/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/*
 *  PA0 -> ADC1 -> DMA -> raw_sensor_value[0] -> characterized sensor outputs
 *			^
 *			|
 * 			TIM2
 *
 *	ClosedLoop/OpenLoop Operation Mode -> dutyCycle -> PWM
 *
 *
 */

/*
 * USART 2->STLINK
 *
 * TX->PA2
 * RX->PA3
 *
 */

#include <string.h>
#include "stm32f446xx.h"

float packets_value[5]; 	//Data packet to be sent via UART

uint8_t heartbeat[2];

GPIO_Handle_t LED;

void LED_GPIOInits(void)
{
	LED.pGPIOx = GPIOA;
	LED.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	//LED.GPIO_PinConfig.GPIO_PinAltFunMode = 2;
	LED.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	LED.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
	LED.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
	//LED D13
	LED.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_5;
	GPIO_Init(&LED);
}

int main(void)
{
	SystemCLK_Config_84MHz();

	SCB_CPACR |= ((3UL << 10*2) | (3UL << 11*2)); //FPU Enabled`

	ControlInit();

	ProtocolInit(USART2, GPIOA, GPIOA, GPIO_PIN_NO_2, GPIO_PIN_NO_3, packets_value, heartbeat);
	Protocol_TIMInit(TIM3);
	Protocol_Start();

	//Call Protocol_Telemetry_EN() to send values in @packets_value

	LED_GPIOInits();
	while(1)
	{
		Protocol_HeartBeat();
		Protocol_Telemetry();
	}
	return 0;
}

void LED_Indicator(void)
{
	if(((heartbeat[0] >> SYSTEM_STATUS_FLAG) & 0b1) == FLAG_SET)
	{
		GPIO_WriteToOutputPin(LED.pGPIOx, GPIO_PIN_NO_5, ENABLE);
	}else if(((heartbeat[0] >> SYSTEM_STATUS_FLAG) & 0b1) == FLAG_RESET)
	{
		GPIO_WriteToOutputPin(LED.pGPIOx, GPIO_PIN_NO_5, DISABLE);
	}
}

void TIM3_IRQHandler(void)
{
	Protocol_HeartBeat_EN();
	Protocol_TIMx_IRQHandling();
	if(((heartbeat[0] >> SYSTEM_STATUS_FLAG) & 0b1) && ((heartbeat[0] >> MODE_FLAG) & 0b1)) GPIO_ToggleOutputPin(LED.pGPIOx, GPIO_PIN_NO_5);
}

void DMA1_Stream6_IRQHandler(void)
{
	Protocol_DMAx_TX_IRQHandling();
}

void DMA1_Stream5_IRQHandler(void)
{
	Protocol_DMAx_RX_IRQHandling();
}

void TIM2_IRQHandler(void)
{
	TIM2_IRQHandling();

	if(Control_ReadSensors(packets_value) == FLAG_RESET) Protocol_Telemetry_EN();
	
	Control_DutyCycle();

}

void executeCommand(uint8_t command)
{
	if(command == 1)					//System ON
	{
		SYSTEM_ON_FLAG(heartbeat[0]);
	}else if(command == 2)				//System OFF
	{
		SYSTEM_OFF_FLAG(heartbeat[0]);
	}else if(command == 3)				//Open Loop
	{
		SET_OPEN_LOOP_MODE(heartbeat[0]);
	}else if(command == 4)				//Closed Loop
	{
		SET_CLOSED_LOOP_MODE(heartbeat[0]);
	}
	heartbeat[0] = Control_Mode(heartbeat[0] & 0b1, (heartbeat[0] >> 1) & 0b1); //Introduce Power & Loop values
	LED_Indicator();
}

/*This interruption can be triggered by GPIOB 14-15*/
void EXTI15_10_IRQHandler(void)
{
	uint8_t temp_toggle_loop = GPIO_ReadFromInputPin(GPIOB, GPIO_PIN_NO_14);
	uint8_t temp_toggle_power = GPIO_ReadFromInputPin(GPIOB, GPIO_PIN_NO_15);

	GPIO_IRQHandling(GPIO_PIN_NO_14);
	GPIO_IRQHandling(GPIO_PIN_NO_15);

	if (temp_toggle_power){
		heartbeat[0] ^= (1 << 0); //toggle power bit if button pressed
	} 
	if (temp_toggle_loop){
		heartbeat[0] ^= (1 << 1); //toggle loop bit if button pressed
	} 

	heartbeat[0] = Control_Mode(heartbeat[0] & 0b1, (heartbeat[0] >> 1) & 0b1); //Introduce Power & Loop values (TO-DO: maybe change to main.c)
	LED_Indicator();
}


uint64_t comm[3] = {RESET}; //lo anadi para revisar que compilara

