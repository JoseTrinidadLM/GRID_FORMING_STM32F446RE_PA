/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/*
 *  PA0 -> ADC1 -> DMA -> value[0] -> raw_sensor_value[0]
 *			^
 *			|
 * 			TIM2
 *
 */

#include "stm32f446xx.h"

float v_cd;
float v_g;
float i_L;
float i_L90;
float i_inv;

float u_ol_pos;
float u_ol_neg;

uint8_t OPERATION_MODE = 0;

GPIO_Handle_t PWM_EN;
GPIO_Handle_t LOOP_SEL;

void Utility_GPIOInits(void)
{
	GPIO_PClkC(GPIOB, ENABLE);
	PWM_EN.pGPIOx = GPIOB;
	PWM_EN.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_14;
	PWM_EN.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IT_RFT;
	PWM_EN.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
	GPIO_Init(&PWM_EN);

	LOOP_SEL.pGPIOx = GPIOB;
	LOOP_SEL.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_15;
	LOOP_SEL.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IT_RFT;
	LOOP_SEL.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
	GPIO_Init(&LOOP_SEL);

	GPIO_IRQInterruptConfig(IRQ_NO_EXTI15_10,ENABLE);
	GPIO_IRQPriorityConfig(IRQ_NO_EXTI15_10, 0); //
}

GPIO_Handle_t GpioPWMA;
GPIO_Handle_t GpioPWMB;

void PWM_GPIOInits(void)
{
	GPIO_PClkC(GPIOC, ENABLE);

	GpioPWMA.pGPIOx = GPIOC;
	GpioPWMA.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_7;
	GpioPWMA.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	GpioPWMA.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;
	GpioPWMA.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	GpioPWMA.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
	GPIO_Init(&GpioPWMA);

	GPIO_PClkC(GPIOA, ENABLE);

	GpioPWMB.pGPIOx = GPIOA;
	GpioPWMB.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_9;
	GpioPWMB.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	GpioPWMB.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;
	GpioPWMB.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	GpioPWMB.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
	GPIO_Init(&GpioPWMB);

	GPIOC->BSRR = ( 1 << ( 7 + 16 ) );
	GPIOA->BSRR = ( 1 << ( 9 + 16 ) );
}


GPIO_Handle_t GPIO_Sensor[4];
ADC_Handle_t ADC_1;
DMA_Handle_t DMA_2;
uint32_t raw_sensor_value[4];
float	sensor[4];

/*Add as much sensors you want to read (look up pinout for compatibility) */

void Sensors_Init(void) /*For this application only 4 sensors will be initialized (name may be changed)*/
{
	/*****************GPIO analog inputs initialization*****************/
	GPIO_PClkC(GPIOA, ENABLE);

	GPIO_Sensor[0].pGPIOx = GPIOA;
	GPIO_Sensor[0].GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ANALOG;
	GPIO_Sensor[0].GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_0;
	GPIO_Sensor[0].GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
	GPIO_Init(&GPIO_Sensor[0]);

	GPIO_Sensor[1].pGPIOx = GPIOA;
	GPIO_Sensor[1].GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ANALOG;
	GPIO_Sensor[1].GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_1;
	GPIO_Sensor[1].GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
	GPIO_Init(&GPIO_Sensor[1]);

	GPIO_Sensor[2].pGPIOx = GPIOA;
	GPIO_Sensor[2].GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ANALOG;
	GPIO_Sensor[2].GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_4;
	GPIO_Sensor[2].GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
	GPIO_Init(&GPIO_Sensor[2]);


	GPIO_Sensor[3].pGPIOx = GPIOA;
	GPIO_Sensor[3].GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ANALOG;
	GPIO_Sensor[3].GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_6;
	GPIO_Sensor[3].GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
	GPIO_Init(&GPIO_Sensor[3]);

	/*****************ADC1 initialization*****************/

	/*ADC configured to start conversion by external trigger set by TIM2 and transfer data via DMA*/
	ADC_PClkC(ADC1, ENABLE);

   	ADC_1.pADCx = ADC1;
	ADC_1.ADC_Config.ADC_Resolution = ADC_RESOLUTION_12_B;
	ADC_1.ADC_Config.ADC_DataAlignment = ADC_DATA_ALIGNMENT_RIGHT;
	ADC_1.ADC_Config.ADC_ScanMode =  ADC_SCAN_MODE_EN;
	ADC_1.ADC_Config.ADC_ConversionMode =  ADC_CONV_MODE_SINGLE;
	ADC_1.ADC_Config.ADC_ExternalTriggerDetection =  ADC_EXT_TRIG_DECT_RE;
	ADC_1.ADC_Config.ADC_ExternalTrigger =  ADC_EXT_TRIG_TIM2_TRGO;
	ADC_1.ADC_Config.ADC_DMAContinuousRequests =  ADC_DMA_MODE_EN;
	ADC_1.ADC_Config.ADC_DDSelection =  ADC_DDS_RQ;
	ADC_1.ADC_Config.ADC_EOCSelection =  ADC_EOC_PER_CONVERSION;
	ADC_1.ADC_Config.ADC_EOCInterrupt =  ADC_EOC_IT_DI;

	/*User may config reading sequence*/
	ADC_1.ADC_NumChannels = 4;
	ADC_ChannelConfig(&ADC_1, 0, 0, ADC_SMP_T_15);
	ADC_ChannelConfig(&ADC_1, 1, 1, ADC_SMP_T_15);
	ADC_ChannelConfig(&ADC_1, 4, 2, ADC_SMP_T_15);
	ADC_ChannelConfig(&ADC_1, 6, 3, ADC_SMP_T_15);
	ADC_ConfigSequence(&ADC_1);
	ADC_Init(&ADC_1);

	/*****************DMA initialization*****************/
	DMA_PClkC(DMA2, ENABLE);

	/*To transfer data from ADC1 to memory it uses Channel 0 and Stream 0*/
	/*To change this look up to Table 28-29 of RM0390 p.205*/
	DMA_2.pDMAx = DMA2;

  	DMA_2.DMA_stream = 0;
	DMA_2.DMA_Config.DMA_Channel = DMA_CHANNEL_0;
	DMA_2.DMA_Config.DMA_Direction = DMA_DIR_PERIPH_TO_MEM;
	DMA_2.DMA_Config.DMA_Priority = DMA_PRIORITY_HIGH;
	DMA_2.DMA_Config.DMA_MemDataSize = DMA_DATA_SIZE_WORD;
	DMA_2.DMA_Config.DMA_PeriphDataSize = DMA_DATA_SIZE_WORD;
	DMA_2.DMA_Config.DMA_MemInc = ENABLE;
	DMA_2.DMA_Config.DMA_PeriphInc = DISABLE;
	DMA_2.DMA_Config.DMA_FIFOMode = DMA_FIFO_MODE_DISABLED;
	DMA_2.DMA_Config.DMA_FIFOThreshold = 0;
	DMA_2.DMA_Config.DMA_Mode = DMA_MODE_CIRCULAR;
	DMA_2.BufferSize = 4; //same number of sensors added

	DMA_Init(&DMA_2);
	DMA_SetAddresses(&DMA_2,(void*)&ADC_1.pADCx->DR,(void*)raw_sensor_value);
	DMA_StartTransfer(&DMA_2);
}

TIM_Handle_t TIM_2;

void SampligRateConfig(float sampling_rate) /*Name may change*/
{

	TIM_2.pTIMx = TIM2;
	TIM_2.TIM_Config.TIM_Frequency = sampling_rate;
	TIM_2.TIM_Config.TIM_CLKDivision = TIM_CKD_DIV1;
	TIM_2.TIM_Config.TIM_AutoReloadPreload = TIM_ARPE_ENABLE;
	TIM_2.TIM_Config.TIM_CNTMode = TIM_UPCOUNT_MODE;
	TIM_2.TIM_Config.TIM_IntEnable = TIM_IT_ENABLE;
	TIM_2.TIM_Config.TIM_MasterModeSel = TIM_MMS_UPDATE; //Master Mode established as update to trigger ADC1 conversion
	TIM_Init(&TIM_2);

	TIM_IRQInterruptConfig(IRQ_NO_TIM2, ENABLE);
	TIM_IRQPriorityConfig(IRQ_NO_TIM2, 2);
}

TIM_Handle_t TIM_5;

void PWMInit(float carrier_frequency) /*Name may change*/
{
	TIM_5.pTIMx = TIM5;
	TIM_5.TIM_Config.TIM_Frequency = carrier_frequency*40; //Triangular carrier wave changes in even steps of Peak-to-Peak/20
	TIM_5.TIM_Config.TIM_CLKDivision = TIM_CKD_DIV1;
	TIM_5.TIM_Config.TIM_AutoReloadPreload = TIM_ARPE_ENABLE;
	TIM_5.TIM_Config.TIM_CNTMode = TIM_UPCOUNT_MODE;
	TIM_5.TIM_Config.TIM_IntEnable = TIM_IT_ENABLE;
	TIM_5.TIM_Config.TIM_MasterModeSel = TIM_MMS_RESET;
	TIM_Init(&TIM_5);

	TIM_IRQInterruptConfig(IRQ_NO_TIM5, ENABLE);
	TIM_IRQPriorityConfig(IRQ_NO_TIM5, 1);
}

int main(void)
{
	SystemCLK_Config_84MHz();

	SCB_CPACR |= ((3UL << 10*2) | (3UL << 11*2)); //FPU Enabled

	Utility_GPIOInits();
	PWM_GPIOInits();
	Sensors_Init();
	SampligRateConfig(9600);
	PWMInit(9600);

	TIM_Start(&TIM_2);
	TIM_Start(&TIM_5);

	while(1);
	return 0;
}

float inc = 0.1;

void TIM5_IRQHandler(void)
{
	static __vo float cont = -1.1;
	static __vo uint8_t dir = 0;
	static __vo uint8_t current_state[2] = {0};
	static __vo uint8_t last_state[2] = {0};

	TIM_IRQHandling(&TIM_5);

	if((dir==0) && (cont<1.0)) cont+=inc;
	else if((dir==0) && (cont>=1.0)) dir = 1;

	if((dir==1) && (cont>-1.0)) cont-=inc;
	else if((dir==1) && (cont<=0))
		{
			dir = 0;
			cont+=inc;
		}

	if(u_ol_pos > cont) current_state[0] = 1;
	else current_state[0] = 0;

	if(u_ol_neg > cont) current_state[1] = 1;
	else current_state[1] = 0;

	if(current_state[0] != last_state[0])
	{
		if(current_state[0])
			GPIOC->BSRR = ( 1 << 7 );
		else
			GPIOC->BSRR = ( 1 << ( 7 + 16 ) );
		last_state[0] = current_state[0];
	}

	if(current_state[1] != last_state[1])
	{
		if(current_state[1])
			GPIOA->BSRR = ( 1 << 9 );
		else
			GPIOA->BSRR = ( 1 << ( 9 + 16 ) );
		last_state[1] = current_state[1];
	}

}



void TIM2_IRQHandler(void)
{
	TIM_IRQHandling(&TIM_2);
	if(OPERATION_MODE == 0)
	{
		u_ol_pos = (raw_sensor_value[0]/4095.0f - 0.5f)*2.0f;
		u_ol_neg = (raw_sensor_value[0]/4095.0f - 0.5f)*(-2.0f);
	} else
	{
		/*TO DO: Implement Closed Loop Operation*/
		u_ol_pos = 0;
		u_ol_neg = 0;
	}
}


void EXTI15_10_IRQHandler(void)
{
	static uint8_t PWM_ENABLE = 0;
	GPIO_IRQHandling(14);
	PWM_ENABLE = GPIO_ReadFromInputPin(GPIOB, 14);
	OPERATION_MODE = GPIO_ReadFromInputPin(GPIOB, 15);
	if( PWM_ENABLE == 0 )
	{
		TIM_Stop(&TIM_5);
		GPIOC->BSRR = ( 1 << ( 7 + 16 ) );
		GPIOA->BSRR = ( 1 << ( 9 + 16 ) );

	} else if( PWM_ENABLE==1 )
	{
		TIM_Start(&TIM_5);
	}
}
